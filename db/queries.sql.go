// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const createAddress = `-- name: CreateAddress :exec
INSERT INTO addresses
(id, user_id, address, number, zip_code, city, state)
VALUES
($1, $2, $3, $4, $5, $6, $7)
`

type CreateAddressParams struct {
	ID      uuid.UUID
	UserID  uuid.UUID
	Address string
	Number  string
	ZipCode string
	City    string
	State   string
}

func (q *Queries) CreateAddress(ctx context.Context, arg CreateAddressParams) error {
	_, err := q.db.ExecContext(ctx, createAddress,
		arg.ID,
		arg.UserID,
		arg.Address,
		arg.Number,
		arg.ZipCode,
		arg.City,
		arg.State,
	)
	return err
}

const createOrder = `-- name: CreateOrder :exec
INSERT INTO orders
(id, user_id, address_id, total_value, product_id, quantity)
VALUES
($1, $2, $3, $4, $5, $6)
`

type CreateOrderParams struct {
	ID         uuid.UUID
	UserID     uuid.UUID
	AddressID  uuid.UUID
	TotalValue int32
	ProductID  int32
	Quantity   int32
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) error {
	_, err := q.db.ExecContext(ctx, createOrder,
		arg.ID,
		arg.UserID,
		arg.AddressID,
		arg.TotalValue,
		arg.ProductID,
		arg.Quantity,
	)
	return err
}

const createProduct = `-- name: CreateProduct :exec
INSERT INTO products (name, value) VALUES ($1, $2)
`

type CreateProductParams struct {
	Name  string
	Value int32
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) error {
	_, err := q.db.ExecContext(ctx, createProduct, arg.Name, arg.Value)
	return err
}

const createUser = `-- name: CreateUser :exec
INSERT INTO users (id, name, email, password) VALUES ($1, $2, $3, $4)
`

type CreateUserParams struct {
	ID       uuid.UUID
	Name     string
	Email    string
	Password string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.ExecContext(ctx, createUser,
		arg.ID,
		arg.Name,
		arg.Email,
		arg.Password,
	)
	return err
}

const deleteAddress = `-- name: DeleteAddress :exec
DELETE FROM addresses WHERE id = $1 AND user_id = $2
`

type DeleteAddressParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) DeleteAddress(ctx context.Context, arg DeleteAddressParams) error {
	_, err := q.db.ExecContext(ctx, deleteAddress, arg.ID, arg.UserID)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const getAddressById = `-- name: GetAddressById :one
SELECT id, user_id, address, number, zip_code, city, state FROM addresses WHERE id = $1 AND user_id = $2
`

type GetAddressByIdParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) GetAddressById(ctx context.Context, arg GetAddressByIdParams) (Address, error) {
	row := q.db.QueryRowContext(ctx, getAddressById, arg.ID, arg.UserID)
	var i Address
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Address,
		&i.Number,
		&i.ZipCode,
		&i.City,
		&i.State,
	)
	return i, err
}

const getAddresses = `-- name: GetAddresses :many
SELECT id, user_id, address, number, zip_code, city, state FROM addresses WHERE user_id = $1
`

func (q *Queries) GetAddresses(ctx context.Context, userID uuid.UUID) ([]Address, error) {
	rows, err := q.db.QueryContext(ctx, getAddresses, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Address
	for rows.Next() {
		var i Address
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Address,
			&i.Number,
			&i.ZipCode,
			&i.City,
			&i.State,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeitaledOrderById = `-- name: GetDeitaledOrderById :one
SELECT u.name, u.email, o.total_value, o.quantity, p.name as product_name, a.state, a.address, a.number, a.zip_code, a.city
FROM users u
JOIN orders o
ON o.id = $1
AND u.id = $2
JOIN products p
ON p.id = o.product_id
JOIN addresses a
ON a.id = o.address_id
AND a.user_id = u.id
`

type GetDeitaledOrderByIdParams struct {
	ID   uuid.UUID
	ID_2 uuid.UUID
}

type GetDeitaledOrderByIdRow struct {
	Name        string
	Email       string
	TotalValue  int32
	Quantity    int32
	ProductName string
	State       string
	Address     string
	Number      string
	ZipCode     string
	City        string
}

func (q *Queries) GetDeitaledOrderById(ctx context.Context, arg GetDeitaledOrderByIdParams) (GetDeitaledOrderByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getDeitaledOrderById, arg.ID, arg.ID_2)
	var i GetDeitaledOrderByIdRow
	err := row.Scan(
		&i.Name,
		&i.Email,
		&i.TotalValue,
		&i.Quantity,
		&i.ProductName,
		&i.State,
		&i.Address,
		&i.Number,
		&i.ZipCode,
		&i.City,
	)
	return i, err
}

const getOrderById = `-- name: GetOrderById :one
SELECT id, user_id, product_id, quantity, total_value, address_id FROM orders WHERE id = $1 AND user_id = $2
`

type GetOrderByIdParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) GetOrderById(ctx context.Context, arg GetOrderByIdParams) (Order, error) {
	row := q.db.QueryRowContext(ctx, getOrderById, arg.ID, arg.UserID)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProductID,
		&i.Quantity,
		&i.TotalValue,
		&i.AddressID,
	)
	return i, err
}

const getOrders = `-- name: GetOrders :many
SELECT id, user_id, product_id, quantity, total_value, address_id FROM orders WHERE user_id = $1
`

func (q *Queries) GetOrders(ctx context.Context, userID uuid.UUID) ([]Order, error) {
	rows, err := q.db.QueryContext(ctx, getOrders, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProductID,
			&i.Quantity,
			&i.TotalValue,
			&i.AddressID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductById = `-- name: GetProductById :one
SELECT id, name, value FROM products WHERE id = $1
`

func (q *Queries) GetProductById(ctx context.Context, id int32) (Product, error) {
	row := q.db.QueryRowContext(ctx, getProductById, id)
	var i Product
	err := row.Scan(&i.ID, &i.Name, &i.Value)
	return i, err
}

const getProducts = `-- name: GetProducts :many
SELECT id, name, value FROM products
`

func (q *Queries) GetProducts(ctx context.Context) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, getProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(&i.ID, &i.Name, &i.Value); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, name, email, password FROM users WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Password,
	)
	return i, err
}

const getUserById = `-- name: GetUserById :one
SELECT id, name, email, password FROM users WHERE id = $1
`

func (q *Queries) GetUserById(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserById, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Password,
	)
	return i, err
}

const getUsersByProduct = `-- name: GetUsersByProduct :many
SELECT u.name, u.email, o.total_value, o.quantity, o.id as order_id, a.state, a.address, a.number, a.zip_code, a.city
FROM users u
JOIN orders o
ON o.product_id = $1
JOIN addresses a
ON a.id = o.address_id
WHERE u.id = o.user_id
`

type GetUsersByProductRow struct {
	Name       string
	Email      string
	TotalValue int32
	Quantity   int32
	OrderID    uuid.UUID
	State      string
	Address    string
	Number     string
	ZipCode    string
	City       string
}

func (q *Queries) GetUsersByProduct(ctx context.Context, productID int32) ([]GetUsersByProductRow, error) {
	rows, err := q.db.QueryContext(ctx, getUsersByProduct, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersByProductRow
	for rows.Next() {
		var i GetUsersByProductRow
		if err := rows.Scan(
			&i.Name,
			&i.Email,
			&i.TotalValue,
			&i.Quantity,
			&i.OrderID,
			&i.State,
			&i.Address,
			&i.Number,
			&i.ZipCode,
			&i.City,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAddress = `-- name: UpdateAddress :exec
UPDATE addresses
SET address = $3, number = $4, zip_code = $5, city = $6, state = $7
WHERE id = $1 AND user_id = $2
`

type UpdateAddressParams struct {
	ID      uuid.UUID
	UserID  uuid.UUID
	Address string
	Number  string
	ZipCode string
	City    string
	State   string
}

func (q *Queries) UpdateAddress(ctx context.Context, arg UpdateAddressParams) error {
	_, err := q.db.ExecContext(ctx, updateAddress,
		arg.ID,
		arg.UserID,
		arg.Address,
		arg.Number,
		arg.ZipCode,
		arg.City,
		arg.State,
	)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users set name = $2, email = $3, password = $4 WHERE id = $1
`

type UpdateUserParams struct {
	ID       uuid.UUID
	Name     string
	Email    string
	Password string
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.ExecContext(ctx, updateUser,
		arg.ID,
		arg.Name,
		arg.Email,
		arg.Password,
	)
	return err
}
